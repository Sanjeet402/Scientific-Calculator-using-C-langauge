HomeDashboardController
// src/main/java/com/payrollbackend/controller/HomeDashboardController.java
package com.payrollbackend.controller;

import com.payrollbackend.dto.HomeDashboardDTO;
import com.payrollbackend.service.HomeDashboardService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
@CrossOrigin(origins = "http://localhost:3000")

@RestController
@RequestMapping("/api/dashboard")
public class HomeDashboardController {
    @Autowired
    private HomeDashboardService dashboardService;

    @GetMapping
    public HomeDashboardDTO homeDashboard() {
        return dashboardService.getDashboard();
    }
}

HomeDashboardDTO
package com.payrollbackend.dto;

import java.util.List;

public class HomeDashboardDTO {
    private int pendingApprovalCount;
    private int rejectedCount;
    private int processedCount;
    private List<BatchSummaryDTO> recentBatches;

    // Getters and Setters

    public int getPendingApprovalCount() {
        return pendingApprovalCount;
    }
    public void setPendingApprovalCount(int pendingApprovalCount) {
        this.pendingApprovalCount = pendingApprovalCount;
    }
    public int getRejectedCount() {
        return rejectedCount;
    }
    public void setRejectedCount(int rejectedCount) {
        this.rejectedCount = rejectedCount;
    }
    public int getProcessedCount() {
        return processedCount;
    }
    public void setProcessedCount(int processedCount) {
        this.processedCount = processedCount;
    }
    public List<BatchSummaryDTO> getRecentBatches() {
        return recentBatches;
    }
    public void setRecentBatches(List<BatchSummaryDTO> recentBatches) {
        this.recentBatches = recentBatches;
    }
}

BatchSummaryDTO
package com.payrollbackend.dto;

public class BatchSummaryDTO {
    private String batchId;

    private String amount;
    private String status;
    private String date;

    public BatchSummaryDTO() {}

    public BatchSummaryDTO(String batchId, String amount, String status, String date) {
        this.batchId = batchId;

        this.amount = amount;
        this.status = status;
        this.date = date;
    }

    // Getters and Setters

    public String getBatchId() { return batchId; }
    public void setBatchId(String batchId) { this.batchId = batchId; }



    public String getAmount() { return amount; }
    public void setAmount(String amount) { this.amount = amount; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getDate() { return date; }
    public void setDate(String date) { this.date = date; }
}

PayrollBatch
package com.payrollbackend.model;

import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "payroll_batch")
public class PayrollBatch {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "batch_reference", unique = true, nullable = false)
    private String batchReference;

    @Column(name = "created_by", nullable = false)
    private String createdBy;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    @ManyToOne(optional = true)
    @JoinColumn(name = "debit_account_id", nullable = true)
    private Account debitAccount;

    @Column(name = "max_debit_amount", nullable = false)
    private Double maxDebitAmount;

    @Column(name = "total_debit_amount", nullable = false)
    private Double totalDebitAmount;

    @Column(name = "status", nullable = false)
    private String status;

    @Column(name = "currency", nullable = false)
    private String currency;

    @OneToMany(mappedBy = "batch", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonManagedReference
    private List<PayrollBatchPayment> payments;

    public PayrollBatch() {}

    // Getters and setters as before

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getBatchReference() { return batchReference; }
    public void setBatchReference(String batchReference) { this.batchReference = batchReference; }

    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

    public Account getDebitAccount() { return debitAccount; }
    public void setDebitAccount(Account debitAccount) { this.debitAccount = debitAccount; }

    public Double getMaxDebitAmount() { return maxDebitAmount; }
    public void setMaxDebitAmount(Double maxDebitAmount) { this.maxDebitAmount = maxDebitAmount; }

    public Double getTotalDebitAmount() { return totalDebitAmount; }
    public void setTotalDebitAmount(Double totalDebitAmount) { this.totalDebitAmount = totalDebitAmount; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public List<PayrollBatchPayment> getPayments() { return payments; }
    public void setPayments(List<PayrollBatchPayment> payments) { this.payments = payments; }

    public String getCurrency() { return currency; }
    public void setCurrency(String currency) { this.currency = currency; }
}

PayrollBatchPayments
package com.payrollbackend.model;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;

@Entity
@Table(name = "payroll_batch_payment")
public class PayrollBatchPayment {
    @Id

    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "batch_id", nullable = false)
    @JsonBackReference
    private PayrollBatch batch;

    @Column(name = "employee_id", nullable = false)
    private String employeeId;

    @Column(name = "employee_name", nullable = false)
    private String employeeName;

    @Column(name = "salary_amount", nullable = false)
    private Double salaryAmount;

    @Column(name = "currency", nullable = false)
    private String currency;

    @Column(name = "employee_account_no", nullable = false)
    private String employeeAccountNo;

    @Column(name = "status", nullable = false)
    private String status;

    public PayrollBatchPayment() {}

    // Getters and setters

    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public PayrollBatch getBatch() { return batch; }
    public void setBatch(PayrollBatch batch) { this.batch = batch; }

    public String getEmployeeId() { return employeeId; }
    public void setEmployeeId(String employeeId) { this.employeeId = employeeId; }

    public String getEmployeeName() { return employeeName; }
    public void setEmployeeName(String employeeName) { this.employeeName = employeeName; }

    public Double getSalaryAmount() { return salaryAmount; }
    public void setSalaryAmount(Double salaryAmount) { this.salaryAmount = salaryAmount; }

    public String getCurrency() { return currency; }
    public void setCurrency(String currency) { this.currency = currency; }

    public String getEmployeeAccountNo() { return employeeAccountNo; }
    public void setEmployeeAccountNo(String employeeAccountNo) { this.employeeAccountNo = employeeAccountNo; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
}

PayrollBatchPaymentRepository
package com.payrollbackend.repository;

import com.payrollbackend.model.PayrollBatchPayment;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface PayrollBatchPaymentRepository extends JpaRepository<PayrollBatchPayment, Long> {
    List<PayrollBatchPayment> findByBatch_BatchReference(String batchReference);
    List<PayrollBatchPayment> findByBatch_DebitAccount_Id(Long accountId);

}

PayrollBatchRepository
package com.payrollbackend.repository;

import com.payrollbackend.model.PayrollBatch;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.LocalDateTime; // <-- Import this
import java.util.List;          // <-- Import this

public interface PayrollBatchRepository extends JpaRepository<PayrollBatch, Long> {

    PayrollBatch findByBatchReference(String batchReference);

    List<PayrollBatch> findByDebitAccount_IdAndStatusOrderByCreatedAtAsc(Long accountId, String approved);

    // --- FIX 1: This was "Arrays", changed to "List<PayrollBatch>" ---
    List<PayrollBatch> findByDebitAccount_IdAndCurrencyAndStatus(Long accountId, String currency, String approved);

    // --- FIX 2: Added the new method for date filtering ---
    @Query("SELECT b FROM PayrollBatch b WHERE " +
            "b.debitAccount.id = :accountId AND " +
            "b.status = :status AND " +
            "(CAST(:startDate as timestamp) IS NULL OR b.createdAt >= :startDate) AND " + // <-- Fixed
            "(CAST(:endDate as timestamp) IS NULL OR b.createdAt <= :endDate) " +      // <-- Fixed
            "ORDER BY b.createdAt ASC")
    List<PayrollBatch> findBatchesByAccountAndStatusAndDateRange(
            @Param("accountId") Long accountId,
            @Param("status") String status,
            @Param("startDate") LocalDateTime startDate,
            @Param("endDate") LocalDateTime endDate
    );
}

HomeDashboardService
// src/main/java/com/payrollbackend/service/HomeDashboardService.java
package com.payrollbackend.service;

import com.payrollbackend.dto.*;
import com.payrollbackend.model.PayrollBatch;
import com.payrollbackend.repository.PayrollBatchRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.format.DateTimeFormatter;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;
import java.util.stream.Collectors;

@Service
public class HomeDashboardService {
    @Autowired
    private PayrollBatchRepository batchRepo;

    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("MMM dd, yyyy", Locale.ENGLISH);

    public HomeDashboardDTO getDashboard() {
        List<PayrollBatch> all = batchRepo.findAll();

        int pending = (int) all.stream().filter(b -> "PENDING".equalsIgnoreCase(b.getStatus())).count();
        int rejected = (int) all.stream().filter(b -> "REJECTED".equalsIgnoreCase(b.getStatus())).count();
        int processed = (int) all.stream().filter(b -> "APPROVED".equalsIgnoreCase(b.getStatus())).count();

        List<BatchSummaryDTO> recentBatches = all.stream()
                .sorted(Comparator.comparing(PayrollBatch::getCreatedAt).reversed())
                .limit(5)
                .map(batch -> new BatchSummaryDTO(
                        batch.getBatchReference(), // Batch ID
                        formatAmount(batch.getTotalDebitAmount(), batch.getCurrency()),
                        batch.getStatus(),
                        batch.getCreatedAt().format(DATE_FORMATTER)
                ))
                .collect(Collectors.toList());

        HomeDashboardDTO dto = new HomeDashboardDTO();
        dto.setPendingApprovalCount(pending);
        dto.setRejectedCount(rejected);
        dto.setProcessedCount(processed);
        dto.setRecentBatches(recentBatches);

        return dto;
    }

    private String formatAmount(Double amount, String currency) {
        if (amount == null || currency == null) return "";
        String symbol = "₹";
        if ("USD".equals(currency)) symbol = "$";
        else if ("EUR".equals(currency)) symbol = "€";
        return symbol + String.format("%,.2f", amount);
    }
}

PayrollBatchService
package com.payrollbackend.service;

import com.payrollbackend.dto.BatchApprovalDTO;
import com.payrollbackend.dto.PaymentDetailDTO;
import com.payrollbackend.model.Account;
import com.payrollbackend.model.PayrollBatch;
import com.payrollbackend.model.PayrollBatchPayment;
import com.payrollbackend.repository.AccountRepository;
import com.payrollbackend.repository.PayrollBatchRepository;
import com.payrollbackend.repository.PayrollBatchPaymentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.payrollbackend.dto.PayrollBatchGridDTO;
import com.payrollbackend.dto.ApprovalBatchListDTO;
import com.payrollbackend.dto.BatchDetailDTO;
import com.payrollbackend.dto.TransactionDetailDTO;
import com.payrollbackend.dto.TransactionPrintDTO;
import com.payrollbackend.dto.TransactionPrintDetailDTO;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Service class for managing payroll batches.
 */
@Service
public class PayrollBatchService {

    private final PayrollBatchRepository batchRepo;
    private final PayrollBatchPaymentRepository paymentRepo;
    private final AccountRepository accountRepository;

    @Autowired
    public PayrollBatchService(PayrollBatchRepository batchRepo, PayrollBatchPaymentRepository paymentRepo, AccountRepository accountRepository) {
        this.batchRepo = batchRepo;
        this.paymentRepo = paymentRepo;
        this.accountRepository = accountRepository;
    }

    // Save a batch (with payments)
    public PayrollBatch saveBatch(PayrollBatch batch) {
        batch.setCreatedAt(LocalDateTime.now());

        // ✅ Resolve debitAccount by ID if provided
        if (batch.getDebitAccount() != null && batch.getDebitAccount().getId() != null) {
            Account account = accountRepository.findById(batch.getDebitAccount().getId())
                    .orElseThrow(() -> new RuntimeException("Invalid debit account ID: " + batch.getDebitAccount().getId()));
            batch.setDebitAccount(account);
        } else {
            throw new RuntimeException("Debit account must be provided");
        }

        // ✅ Make sure all payments reference this batch
        if (batch.getPayments() != null) {
            for (PayrollBatchPayment payment : batch.getPayments()) {
                payment.setBatch(batch);
            }
        }

        return batchRepo.save(batch);
    }


    // Get all batches
    public List<PayrollBatch> getAllBatches() {
        return batchRepo.findAll();
    }

    // Find by batch reference (unique)
    public Optional<PayrollBatch> getBatchByReference(String reference) {
        return batchRepo.findAll().stream()
                .filter(batch -> batch.getBatchReference().equals(reference))
                .findFirst();
    }

    // Get all payments by batch reference
    public List<PayrollBatchPayment> getPaymentsByBatch(PayrollBatch batch) {
        return batch.getPayments();
    }
    public List<PayrollBatchGridDTO> getBatchGridList() {
        return batchRepo.findAll().stream()
                .map(batch -> new PayrollBatchGridDTO(
                        batch.getBatchReference(),
                        batch.getCreatedBy(),
                        batch.getCreatedAt(),
                        batch.getPayments() != null ? batch.getPayments().size() : 0,
                        batch.getMaxDebitAmount(),
                        batch.getTotalDebitAmount(),
                        batch.getStatus(),
                        batch.getCurrency())
                )
                .collect(Collectors.toList());
    }
    // Get batch details with payments for approval/manage page
    public BatchApprovalDTO getBatchDetailsForApproval(String batchReference) {
        PayrollBatch batch = batchRepo.findByBatchReference(batchReference);
        if (batch == null) return null;

        List<PaymentDetailDTO> paymentDetails = batch.getPayments().stream()
                .map(p -> new PaymentDetailDTO(
                        p.getEmployeeId(),
                        p.getEmployeeName(),
                        p.getEmployeeAccountNo(),
                        p.getSalaryAmount(),
                        p.getCurrency(),
                        p.getStatus()
                ))
                .collect(Collectors.toList());

        return new BatchApprovalDTO(
                batch.getId(),
                batch.getBatchReference(),
                batch.getCreatedBy(),
                batch.getCreatedAt(),
                batch.getPayments() != null ? batch.getPayments().size() : 0,
                batch.getMaxDebitAmount(),
                batch.getTotalDebitAmount(),
                batch.getStatus(),
                batch.getCurrency(),
                batch.getDebitAccount() != null ? batch.getDebitAccount().getNumber() : null,
                paymentDetails
        );
    }

    // Get all batches for approval/manage page (list view)
    public List<BatchApprovalDTO> getAllBatchesForApproval() {
        return batchRepo.findAll().stream()
                .map(batch -> {
                    List<PaymentDetailDTO> paymentDetails = batch.getPayments().stream()
                            .map(p -> new PaymentDetailDTO(
                                    p.getEmployeeId(),
                                    p.getEmployeeName(),
                                    p.getEmployeeAccountNo(),
                                    p.getSalaryAmount(),
                                    p.getCurrency(),
                                    p.getStatus()
                            ))
                            .collect(Collectors.toList());

                    return new BatchApprovalDTO(
                            batch.getId(),
                            batch.getBatchReference(),
                            batch.getCreatedBy(),
                            batch.getCreatedAt(),
                            batch.getPayments() != null ? batch.getPayments().size() : 0,
                            batch.getMaxDebitAmount(),
                            batch.getTotalDebitAmount(),
                            batch.getStatus(),
                            batch.getCurrency(),
                            batch.getDebitAccount() != null ? batch.getDebitAccount().getNumber() : null,
                            paymentDetails
                    );
                })
                .collect(Collectors.toList());
    }
    // Add these methods to your existing PayrollBatchService class:

    // Get all batches pending approval
    public List<ApprovalBatchListDTO> getPendingApprovalBatches() {
        return batchRepo.findAll().stream()
                .filter(batch -> "PENDING".equals(batch.getStatus()) || "Batched for Authorization".equals(batch.getStatus()))
                .map(batch -> new ApprovalBatchListDTO(
                        batch.getId(),
                        batch.getBatchReference(),
                        batch.getBatchReference(), // Using reference as name, modify if you have actual name field
                        batch.getCreatedBy(),
                        batch.getCreatedAt(),
                        batch.getDebitAccount() != null ? batch.getDebitAccount().getNumber() : null,
                        batch.getPayments() != null ? batch.getPayments().size() : 0,
                        batch.getCurrency(),
                        batch.getMaxDebitAmount(),
                        batch.getCurrency(),
                        batch.getTotalDebitAmount(),
                        batch.getStatus()
                ))
                .collect(Collectors.toList());
    }

    // Get batch details with transactions
    public BatchDetailDTO getBatchDetailsWithTransactions(String batchReference) {
        PayrollBatch batch = batchRepo.findByBatchReference(batchReference);
        if (batch == null) return null;

        List<TransactionDetailDTO> transactions = batch.getPayments().stream()
                .map(payment -> new TransactionDetailDTO(
                        payment.getId(),
                        payment.getEmployeeName(),
                        payment.getEmployeeAccountNo(),
                        payment.getCurrency(),
                        payment.getSalaryAmount()
                ))
                .collect(Collectors.toList());

        return new BatchDetailDTO(
                batch.getBatchReference(),
                batch.getBatchReference(), // Modify if you have actual batch name
                batch.getCreatedBy(),
                batch.getCreatedAt(),
                batch.getDebitAccount() != null ? batch.getDebitAccount().getNumber() : null,
                batch.getTotalDebitAmount(),
                batch.getCurrency(),
                transactions
        );
    }

    // Approve selected batches
    @Transactional
    public void approveBatches(List<String> batchReferences) {
        for (String ref : batchReferences) {
            PayrollBatch batch = batchRepo.findByBatchReference(ref);
            if (batch != null) {
                if (!"APPROVED".equals(batch.getStatus())) {
                    applyApprovalEffects(batch);
                    batch.setStatus("APPROVED");
                    batchRepo.save(batch);
                }
            }
        }
    }

    // Reject selected batches
    @Transactional
    public void rejectBatches(List<String> batchReferences) {
        for (String ref : batchReferences) {
            PayrollBatch batch = batchRepo.findByBatchReference(ref);
            if (batch != null) {
                // If already approved earlier, refund the amount
                if ("APPROVED".equals(batch.getStatus())) {
                    refundApprovalEffects(batch);
                }
                batch.setStatus("REJECTED");
                batchRepo.save(batch);
            }
        }
    }

    @Transactional
    public PayrollBatch updateStatusAndAdjustBalance(String batchReference, String newStatus) {
        PayrollBatch batch = batchRepo.findByBatchReference(batchReference);
        if (batch == null) return null;

        String currentStatus = batch.getStatus();
        // Transition to APPROVED => apply debit
        if (!"APPROVED".equals(currentStatus) && "APPROVED".equals(newStatus)) {
            applyApprovalEffects(batch);
        }
        // Transition from APPROVED to a non-approved (e.g., REJECTED/RETURNED) => refund debit
        if ("APPROVED".equals(currentStatus) && !"APPROVED".equals(newStatus)) {
            refundApprovalEffects(batch);
        }
        batch.setStatus(newStatus);
        return batchRepo.save(batch);
    }

    private void applyApprovalEffects(PayrollBatch batch) {
        Account account = batch.getDebitAccount();
        if (account == null) return;
        BigDecimal current = account.getBalance() != null ? account.getBalance() : BigDecimal.ZERO;
        BigDecimal debit = BigDecimal.valueOf(batch.getTotalDebitAmount() != null ? batch.getTotalDebitAmount() : 0.0);
        account.setBalance(current.subtract(debit));
        account.setLastUpdated(LocalDateTime.now());
        accountRepository.save(account);
    }

    private void refundApprovalEffects(PayrollBatch batch) {
        Account account = batch.getDebitAccount();
        if (account == null) return;
        BigDecimal current = account.getBalance() != null ? account.getBalance() : BigDecimal.ZERO;
        BigDecimal credit = BigDecimal.valueOf(batch.getTotalDebitAmount() != null ? batch.getTotalDebitAmount() : 0.0);
        account.setBalance(current.add(credit));
        account.setLastUpdated(LocalDateTime.now());
        accountRepository.save(account);
    }

    // Get processed (approved/rejected) batches
    public List<ApprovalBatchListDTO> getProcessedBatches() {
        return batchRepo.findAll().stream()
                .filter(batch -> "APPROVED".equals(batch.getStatus()) || "REJECTED".equals(batch.getStatus()))
                .map(batch -> new ApprovalBatchListDTO(
                        batch.getId(),
                        batch.getBatchReference(),
                        batch.getBatchReference(),
                        batch.getCreatedBy(),
                        batch.getCreatedAt(),
                        batch.getDebitAccount() != null ? batch.getDebitAccount().getNumber() : null,
                        batch.getPayments() != null ? batch.getPayments().size() : 0,
                        batch.getCurrency(),
                        batch.getMaxDebitAmount(),
                        batch.getCurrency(),
                        batch.getTotalDebitAmount(),
                        batch.getStatus()
                ))
                .collect(Collectors.toList());
    }
    /*
     * ============================================
     * PAGE: TRANSACTION PRINT PREVIEW
     * PACKAGE: com.payrollbackend.service
     * PURPOSE: Service methods for transaction print and PDF generation
     * ADD THESE METHODS TO YOUR EXISTING PayrollBatchService.java
     * ============================================
     */

// Add these imports at the top


// Add these methods to your existing PayrollBatchService class:

    // Get all transactions for print preview
    public List<TransactionPrintDTO> getAllTransactionsForPrint() {
        List<TransactionPrintDTO> transactions = new ArrayList<>();

        List<PayrollBatch> batches = batchRepo.findAll();
        for (PayrollBatch batch : batches) {
            for (PayrollBatchPayment payment : batch.getPayments()) {
                String transactionId = "TXN-" + payment.getId();
                transactions.add(new TransactionPrintDTO(
                        transactionId,
                        payment.getEmployeeName(),
                        payment.getCurrency(),
                        payment.getSalaryAmount(),
                        batch.getStatus()
                ));
            }
        }

        return transactions;
    }

    // Get transaction detail for print preview by transaction ID
    public TransactionPrintDetailDTO getTransactionDetailForPrint(String transactionId) {
        // Extract payment ID from transaction ID (TXN-1001 -> 1001)
        Long paymentId = Long.parseLong(transactionId.replace("TXN-", ""));

        PayrollBatchPayment payment = paymentRepo.findById(paymentId).orElse(null);
        if (payment == null) return null;

        PayrollBatch batch = payment.getBatch();

        return new TransactionPrintDetailDTO(
                batch.getStatus(), // e.g., "Batch In-Progress"
                batch.getBatchReference(), // Use actual batch reference
                batch.getCreatedBy(),
                payment.getSalaryAmount().toString(),
                payment.getCurrency(),
                getPaymentTypeForCurrency(payment.getCurrency()),
                batch.getDebitAccount() != null ? batch.getDebitAccount().getNumber() : null,
                payment.getEmployeeName(),
                payment.getEmployeeAccountNo(),
                getBankNameForCurrency(payment.getCurrency())
        );
    }

    // Get multiple transaction details for batch print
    public List<TransactionPrintDetailDTO> getMultipleTransactionDetailsForPrint(List<String> transactionIds) {
        return transactionIds.stream()
                .map(this::getTransactionDetailForPrint)
                .filter(detail -> detail != null)
                .collect(Collectors.toList());
    }

    private String getPaymentTypeForCurrency(String currency) {
        if ("INR".equalsIgnoreCase(currency)) return "NEFT";
        if ("USD".equalsIgnoreCase(currency)) return "SWIFT";
        if ("EUR".equalsIgnoreCase(currency)) return "SEPA";
        return "ACH - AUTOMATED";
    }

    private String getBankNameForCurrency(String currency) {
        if ("INR".equalsIgnoreCase(currency)) return "Standard Chartered Bank";
        if ("USD".equalsIgnoreCase(currency)) return "Standard Chartered Bank (NY)";
        if ("EUR".equalsIgnoreCase(currency)) return "Standard Chartered Bank (Frankfurt)";
        return "Standard Chartered Bank";
    }

}







